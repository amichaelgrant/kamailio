From dd7a49ee775ff5b29bb73c5313c3bfd8a64b26a0 Mon Sep 17 00:00:00 2001
From: Daniel-Constantin Mierla <miconda@gmail.com>
Date: Sun, 12 Oct 2014 23:39:18 +0200
Subject: [PATCH] dialplan: option to allow variables in match and substitution
 expressions

- based on requirement from FS#429
- new parameter: match_dynamic to enable this feature
- if enabled, at load time, the values are searched for variables and if
  any found, then evaluation and pcre compilation is done at runtime
- it can work with rules that don't include variables at the same time,
  these being pre-compiled at load time
---
 modules/dialplan/dialplan.c |  13 ++--
 modules/dialplan/dialplan.h |  33 +++++----
 modules/dialplan/dp_db.c    | 160 +++++++++++++++++++++++++++++++++-----------
 modules/dialplan/dp_repl.c  |  82 ++++++++++++++++++++---
 4 files changed, 222 insertions(+), 66 deletions(-)

diff --git a/modules/dialplan/dialplan.c b/modules/dialplan/dialplan.c
index ebbd6bd..d86eb56 100644
--- a/modules/dialplan/dialplan.c
+++ b/modules/dialplan/dialplan.c
@@ -64,7 +64,7 @@
 
 MODULE_VERSION
 
-#define DEFAULT_PARAM    "$ruri.user"
+#define DEFAULT_PARAM    "$rU"
 
 static int mod_init(void);
 static int child_init(int rank);
@@ -85,6 +85,7 @@ str default_param_s = str_init(DEFAULT_PARAM);
 dp_param_p default_par2 = NULL;
 
 int dp_fetch_rows = 1000;
+int dp_match_dynamic = 0;
 
 static param_export_t mod_params[]={
 	{ "db_url",			PARAM_STR,	&dp_db_url },
@@ -97,8 +98,9 @@ static param_export_t mod_params[]={
 	{ "subst_exp_col",	PARAM_STR,	&subst_exp_column },
 	{ "repl_exp_col",	PARAM_STR,	&repl_exp_column },
 	{ "attrs_col",		PARAM_STR,	&attrs_column },
-	{ "attrs_pvar",	    PARAM_STR,	&attr_pvar_s},
-	{ "fetch_rows",		INT_PARAM,	&dp_fetch_rows},
+	{ "attrs_pvar",	    PARAM_STR,	&attr_pvar_s },
+	{ "fetch_rows",		PARAM_INT,	&dp_fetch_rows },
+	{ "match_dynamic",	PARAM_INT,	&dp_match_dynamic },
 	{0,0,0}
 };
 
@@ -165,7 +167,7 @@ static int mod_init(void)
 	}
 	memset(default_par2, 0, sizeof(dp_param_t));
 
-	/* A.Spiridonov: Some weird sections with default_param processing */
+	/* emulate "$rU/$rU" as second parameter for dp_translate() */
 	default_param_s.len = strlen(default_param_s.s);
 	default_par2->v.sp[0] = pv_cache_get(&default_param_s);
 	if (default_par2->v.sp[0]==NULL) {
@@ -179,7 +181,6 @@ static int mod_init(void)
 		LM_ERR("output pv is invalid\n");
 		return -1;
 	}
-	/* End of weird sections */
 
 	if(dp_fetch_rows<=0)
 		dp_fetch_rows = 1000;
@@ -342,7 +343,7 @@ static int dp_translate_f(struct sip_msg* msg, char* str1, char* str2)
 	LM_DBG("input %.*s with dpid %i => output %.*s\n",
 			input.len, input.s, idp->dp_id, output.len, output.s);
 
-	/*set the output*/
+	/* set the output */
 	if (dp_update(msg, repl_par->v.sp[0], repl_par->v.sp[1],
 				&output, attrs_par) !=0){
 		LM_ERR("cannot set the output\n");
diff --git a/modules/dialplan/dialplan.h b/modules/dialplan/dialplan.h
index f033474..ea976aa 100644
--- a/modules/dialplan/dialplan.h
+++ b/modules/dialplan/dialplan.h
@@ -46,18 +46,25 @@
 
 #define MAX_REPLACE_WITH	10
 
-typedef struct dpl_node{
-	int dpid;
-	int pr;
-	int matchop;
-	int matchlen;
-	str match_exp, subst_exp, repl_exp; /*keeping the original strings*/
-	pcre *match_comp, *subst_comp; /*compiled patterns*/
-	struct subst_expr * repl_comp; 
-	str attrs;
-
-	struct dpl_node * next; /*next rule*/
-}dpl_node_t, *dpl_node_p;
+#define DP_TFLAGS_PV_MATCH		(1 << 0)
+#define DP_TFLAGS_PV_SUBST		(1 << 1)
+
+typedef struct dpl_node {
+	int dpid;         /* dialplan id */
+	int pr;           /* priority */
+	int matchop;      /* matching operator */
+	int matchlen;     /* matching value length */
+	str match_exp;    /* match-first string */
+	str subst_exp;    /* match string with subtitution groupping */
+	str repl_exp;     /* replacement expression string */
+	pcre *match_comp; /* compiled matching expression */
+	pcre *subst_comp; /* compiled substitution expression */
+	struct subst_expr *repl_comp; /* compiled replacement */
+	str attrs;        /* attributes string */
+	unsigned int tflags; /* flags for type of values for matching */
+
+	struct dpl_node * next; /* next rule */
+} dpl_node_t, *dpl_node_p;
 
 /*For every distinct length of a matching string*/
 typedef struct dpl_index{
@@ -97,4 +104,6 @@ struct subst_expr* repl_exp_parse(str subst);
 void repl_expr_free(struct subst_expr *se);
 int translate(struct sip_msg *msg, str user_name, str* repl_user, dpl_id_p idp, str *);
 int rule_translate(struct sip_msg *msg, str , dpl_node_t * rule,  str *);
+
+pcre *reg_ex_comp(const char *pattern, int *cap_cnt, int mtype);
 #endif
diff --git a/modules/dialplan/dp_db.c b/modules/dialplan/dp_db.c
index 1db9d7d..57b0e76 100644
--- a/modules/dialplan/dp_db.c
+++ b/modules/dialplan/dp_db.c
@@ -55,6 +55,7 @@ str repl_exp_column =   str_init(REPL_EXP_COL);
 str attrs_column    =   str_init(ATTRS_COL); 
 
 extern int dp_fetch_rows;
+extern int dp_match_dynamic;
 
 static db1_con_t* dp_db_handle    = 0; /* database connection handle */
 static db_func_t dp_dbf;
@@ -84,6 +85,52 @@ dpl_id_p* rules_hash = NULL;
 int * crt_idx, *next_idx;
 
 
+/**
+ * check if string has pvs
+ * returns -1 if error, 0 if found, 1 if not found
+ */
+int dpl_check_pv(str *in)
+{
+	char *p;
+	pv_spec_t *spec = NULL;
+	str s;
+	int len;
+
+	if(in==NULL || in->s==NULL)
+		return -1;
+
+	LM_DBG("parsing [%.*s]\n", in->len, in->s);
+
+	if(in->len == 0)
+		return 1;
+
+	p = in->s;
+
+	while(is_in_str(p,in))
+	{
+		while(is_in_str(p,in) && *p!=PV_MARKER)
+			p++;
+		if(*p == '\0' || !is_in_str(p,in))
+			break;
+		/* last char is $ ? */
+		if(!is_in_str(p+1, in))
+			break;
+		s.s = p;
+		s.len = in->s+in->len-p;
+		len = 0;
+		spec = pv_spec_lookup(&s, &len);
+		if(spec!=NULL) {
+			/* found a variable */
+			LM_DBG("string [%.*s] has variables\n", in->len, in->s);
+			return 0;
+		}
+		if(len) p += len;
+		else p++;
+	}
+
+	/* not found */
+	return 1;
+}
 
 int init_db_data(void)
 {
@@ -294,12 +341,19 @@ err2:
 }
 
 
-int str_to_shm(str src, str * dest)
+int dpl_str_to_shm(str src, str *dest, int mterm)
 {
+	int mdup = 0;
+
 	if(src.len ==0 || src.s ==0)
 		return 0;
 
-	dest->s = (char*)shm_malloc((src.len+1) * sizeof(char));
+	if(mterm!=0 && PV_MARKER=='$') {
+		if(src.len>1 && src.s[src.len-1]=='$' && src.s[src.len-2]!='$') {
+			mdup = 1;
+		}
+	}
+	dest->s = (char*)shm_malloc((src.len+1+mdup) * sizeof(char));
 	if(!dest->s){
 		LM_ERR("out of shm memory\n");
 		return -1;
@@ -308,13 +362,20 @@ int str_to_shm(str src, str * dest)
 	memcpy(dest->s, src.s, src.len);
 	dest->s[src.len] = '\0';
 	dest->len = src.len;
+	if(mdup) {
+		dest->s[dest->len] = '$';
+		dest->len++;
+		dest->s[dest->len] = '\0';
+	}
 
 	return 0;
 }
 
 
-/* Compile pcre pattern and return pointer to shm copy of result */
-static pcre *reg_ex_comp(const char *pattern, int *cap_cnt)
+/* Compile pcre pattern
+ * if mtype==0 - return pointer to shm copy of result
+ * if mtype==1 - return pcre pointer that has to be pcre_free() */
+pcre *reg_ex_comp(const char *pattern, int *cap_cnt, int mtype)
 {
 	pcre *re, *result;
 	const char *error;
@@ -341,15 +402,19 @@ static pcre *reg_ex_comp(const char *pattern, int *cap_cnt)
 				pattern, rc);
 		return (pcre *)0;
 	}
-	result = (pcre *)shm_malloc(size);
-	if (result == NULL) {
+	if(mtype==0) {
+		result = (pcre *)shm_malloc(size);
+		if (result == NULL) {
+			pcre_free(re);
+			LM_ERR("not enough shared memory for compiled PCRE pattern\n");
+			return (pcre *)0;
+		}
+		memcpy(result, re, size);
 		pcre_free(re);
-		LM_ERR("not enough shared memory for compiled PCRE pattern\n");
-		return (pcre *)0;
+		return result;
+	} else {
+		return re;
 	}
-	memcpy(result, re, size);
-	pcre_free(re);
-	return result;
 }
 
 
@@ -362,6 +427,7 @@ dpl_node_t * build_rule(db_val_t * values)
 	str match_exp, subst_exp, repl_exp, attrs;
 	int matchop;
 	int cap_cnt=0;
+	unsigned int tflags=0;
 
 	matchop = VAL_INT(values+2);
 
@@ -371,17 +437,24 @@ dpl_node_t * build_rule(db_val_t * values)
 		return NULL;
 	}
 
-	match_comp = subst_comp =0;
+	match_comp = subst_comp = 0;
 	repl_comp = 0;
 	new_rule = 0;
 
 	GET_STR_VALUE(match_exp, values, 3);
 	if(matchop == DP_REGEX_OP){
-		match_comp = reg_ex_comp(match_exp.s, &cap_cnt);
-		if(!match_comp){
-			LM_ERR("failed to compile match expression %.*s\n",
-					match_exp.len, match_exp.s);
-			goto err;
+		if(unlikely(dp_match_dynamic==1)) {
+			if(dpl_check_pv(&match_exp)==0) {
+				tflags |= DP_TFLAGS_PV_MATCH;
+			}
+		}
+		if(!(tflags&DP_TFLAGS_PV_MATCH)) {
+			match_comp = reg_ex_comp(match_exp.s, &cap_cnt, 0);
+			if(!match_comp){
+				LM_ERR("failed to compile match expression %.*s\n",
+						match_exp.len, match_exp.s);
+				goto err;
+			}
 		}
 	}
 
@@ -395,18 +468,26 @@ dpl_node_t * build_rule(db_val_t * values)
 		}
 	}
 
+	cap_cnt = 0;
 	GET_STR_VALUE(subst_exp, values, 5);
 	if(subst_exp.s && subst_exp.len){
-		subst_comp = reg_ex_comp(subst_exp.s, &cap_cnt);
-		if(!subst_comp){
-			LM_ERR("failed to compile subst expression %.*s\n",
-					subst_exp.len, subst_exp.s);
-			goto err;
+		if(unlikely(dp_match_dynamic==1)) {
+			if(dpl_check_pv(&subst_exp)==0) {
+				tflags |= DP_TFLAGS_PV_SUBST;
+			}
 		}
-		if (cap_cnt > MAX_REPLACE_WITH) {
-			LM_ERR("subst expression %.*s has too many sub-expressions\n",
-					subst_exp.len, subst_exp.s);
-			goto err;
+		if(!(tflags&DP_TFLAGS_PV_SUBST)) {
+			subst_comp = reg_ex_comp(subst_exp.s, &cap_cnt, 0);
+			if(!subst_comp){
+				LM_ERR("failed to compile subst expression %.*s\n",
+						subst_exp.len, subst_exp.s);
+				goto err;
+			}
+			if (cap_cnt > MAX_REPLACE_WITH) {
+				LM_ERR("subst expression %.*s has too many sub-expressions\n",
+						subst_exp.len, subst_exp.s);
+				goto err;
+			}
 		}
 	}
 
@@ -429,13 +510,15 @@ dpl_node_t * build_rule(db_val_t * values)
 	}
 	memset(new_rule, 0, sizeof(dpl_node_t));
 
-	if(str_to_shm(match_exp, &new_rule->match_exp)!=0)
+	if(dpl_str_to_shm(match_exp, &new_rule->match_exp,
+				tflags&DP_TFLAGS_PV_MATCH)!=0)
 		goto err;
 
-	if(str_to_shm(subst_exp, &new_rule->subst_exp)!=0)
+	if(dpl_str_to_shm(subst_exp, &new_rule->subst_exp,
+				tflags&DP_TFLAGS_PV_SUBST)!=0)
 		goto err;
 
-	if(str_to_shm(repl_exp, &new_rule->repl_exp)!=0)
+	if(dpl_str_to_shm(repl_exp, &new_rule->repl_exp, 0)!=0)
 		goto err;
 
 	/*set the rest of the rule fields*/
@@ -444,14 +527,15 @@ dpl_node_t * build_rule(db_val_t * values)
 	new_rule->matchlen	= 	VAL_INT(values+4);
 	new_rule->matchop	=	matchop;
 	GET_STR_VALUE(attrs, values, 7);
-	if(str_to_shm(attrs, &new_rule->attrs)!=0)
+	if(dpl_str_to_shm(attrs, &new_rule->attrs, 0)!=0)
 		goto err;
 
-	LM_DBG("attrs are %.*s\n", new_rule->attrs.len, new_rule->attrs.s);
+	LM_DBG("attrs are: '%.*s'\n", new_rule->attrs.len, new_rule->attrs.s);
 
 	new_rule->match_comp = match_comp;
 	new_rule->subst_comp = subst_comp;
 	new_rule->repl_comp  = repl_comp;
+	new_rule->tflags     = tflags;
 
 	return new_rule;
 
@@ -662,15 +746,15 @@ void list_hash(int h_index)
 }
 
 
-void list_rule(dpl_node_t * rule)
+void list_rule(dpl_node_t *rule)
 {
-	LM_DBG("RULE %p: pr %i next %p op %d match_exp %.*s, "
+	LM_DBG("RULE %p: pr %i next %p op %d tflags %u match_exp %.*s, "
 			"subst_exp %.*s, repl_exp %.*s and attrs %.*s\n", rule,
 			rule->pr, rule->next,
-			rule->matchop,
-			rule->match_exp.len, rule->match_exp.s, 
-			rule->subst_exp.len, rule->subst_exp.s,
-			rule->repl_exp.len, rule->repl_exp.s,
-			rule->attrs.len,	rule->attrs.s);
+			rule->matchop, rule->tflags,
+			rule->match_exp.len, ZSW(rule->match_exp.s),
+			rule->subst_exp.len, ZSW(rule->subst_exp.s),
+			rule->repl_exp.len, ZSW(rule->repl_exp.s),
+			rule->attrs.len,	ZSW(rule->attrs.s));
 
 }
diff --git a/modules/dialplan/dp_repl.c b/modules/dialplan/dp_repl.c
index eeb9dd1..ee94be8 100644
--- a/modules/dialplan/dp_repl.c
+++ b/modules/dialplan/dp_repl.c
@@ -41,6 +41,43 @@
 #include "dialplan.h"
 
 
+pcre *dpl_dynamic_pcre(sip_msg_t *msg, str *expr, int *cap_cnt)
+{
+	pv_elem_t *pelem = NULL;
+	pcre *re = NULL;
+	int ccnt = 0;
+	str vexpr;
+
+	if(expr==NULL || expr->s==NULL || expr->len<=0)
+		return NULL;
+
+	if(pv_parse_format(expr, &pelem)<0){
+		LM_ERR("parsing pcre expression: %.*s\n",
+				expr->len, expr->s);
+		return NULL;
+	}
+	if(pv_printf_s(msg, pelem, &vexpr)<0){
+		LM_ERR("cannot get pcre dynamic expression value: %.*s\n",
+				expr->len, expr->s);
+		pv_elem_free_all(pelem);
+		return NULL;
+	}
+	pv_elem_free_all(pelem);
+
+	re = reg_ex_comp(vexpr.s, &ccnt, 1);
+	if(!re) {
+		LM_ERR("failed to compile pcre expression: %.*s (%.*s)\n",
+				expr->len, expr->s, vexpr.len, vexpr.s);
+		return NULL;
+	}
+	if(cap_cnt) {
+		*cap_cnt = ccnt;
+	}
+	LM_DBG("compiled dynamic pcre expression: %.*s (%.*s) %d\n",
+				expr->len, expr->s, vexpr.len, vexpr.s, ccnt);
+	return re;
+}
+
 void repl_expr_free(struct subst_expr *se)
 {
 	if(!se)
@@ -126,7 +163,7 @@ error:
 
 #define MAX_PHONE_NB_DIGITS		127
 static char dp_output_buf[MAX_PHONE_NB_DIGITS+1];
-int rule_translate(struct sip_msg *msg, str string, dpl_node_t * rule,
+int rule_translate(sip_msg_t *msg, str string, dpl_node_t * rule,
 		str * result)
 {
 	int repl_nb, offset, match_nb, rc, cap_cnt;
@@ -144,14 +181,18 @@ int rule_translate(struct sip_msg *msg, str string, dpl_node_t * rule,
 	result->s = dp_output_buf;
 	result->len = 0;
 
-	subst_comp 	= rule->subst_comp;
 	repl_comp 	= rule->repl_comp;
-
 	if(!repl_comp){
 		LM_DBG("null replacement\n");
 		return 0;
 	}
 
+	if(rule->tflags&DP_TFLAGS_PV_SUBST) {
+		subst_comp = dpl_dynamic_pcre(msg, &rule->subst_exp, NULL);
+	} else {
+		subst_comp = rule->subst_comp;
+	}
+
 	if(subst_comp){
 		/*just in case something went wrong at load time*/
 		rc = pcre_fullinfo(subst_comp, NULL, PCRE_INFO_CAPTURECOUNT,
@@ -159,22 +200,25 @@ int rule_translate(struct sip_msg *msg, str string, dpl_node_t * rule,
 		if (rc != 0) {
 			LM_ERR("pcre_fullinfo on compiled pattern yielded error: %d\n",
 					rc);
-			return -1;;
+			if(rule->tflags&DP_TFLAGS_PV_SUBST) pcre_free(subst_comp);
+			return -1;
 		}
 		if(repl_comp->max_pmatch > cap_cnt){
-			LM_ERR("illegal access to the %i-th subexpr of the subst expr\n",
-					repl_comp->max_pmatch);
+			LM_ERR("illegal access to %i-th subexpr of subst expr (max %d)\n",
+					repl_comp->max_pmatch, cap_cnt);
+			if(rule->tflags&DP_TFLAGS_PV_SUBST) pcre_free(subst_comp);
 			return -1;
 		}
 
 		/*search for the pattern from the compiled subst_exp*/
-		if (pcre_exec(rule->subst_comp, NULL, string.s, string.len,
+		if (pcre_exec(subst_comp, NULL, string.s, string.len,
 					0, 0, ovector, 3 * (MAX_REPLACE_WITH + 1)) <= 0) {
 			LM_ERR("the string %.*s matched "
 					"the match_exp %.*s but not the subst_exp %.*s!\n", 
 					string.len, string.s, 
 					rule->match_exp.len, rule->match_exp.s,
 					rule->subst_exp.len, rule->subst_exp.s);
+			if(rule->tflags&DP_TFLAGS_PV_SUBST) pcre_free(subst_comp);
 			return -1;
 		}
 	}
@@ -191,6 +235,7 @@ int rule_translate(struct sip_msg *msg, str string, dpl_node_t * rule,
 				repl_comp->replacement.len);
 		result->len = repl_comp->replacement.len;
 		result->s[result->len] = '\0';
+		if(rule->tflags&DP_TFLAGS_PV_SUBST) pcre_free(subst_comp);
 		return 0;
 	}
 
@@ -300,9 +345,12 @@ int rule_translate(struct sip_msg *msg, str string, dpl_node_t * rule,
 	}
 
 	result->s[result->len] = '\0';
+	if(rule->tflags&DP_TFLAGS_PV_SUBST) pcre_free(subst_comp);
 	return 0;
 
 error:
+	if((rule->tflags&DP_TFLAGS_PV_SUBST) && subst_comp!=NULL)
+		pcre_free(subst_comp);
 	result->s = 0;
 	result->len = 0;
 	return -1;
@@ -310,13 +358,14 @@ error:
 
 #define DP_MAX_ATTRS_LEN	128
 static char dp_attrs_buf[DP_MAX_ATTRS_LEN+1];
-int translate(struct sip_msg *msg, str input, str *output, dpl_id_p idp,
+int translate(sip_msg_t *msg, str input, str *output, dpl_id_p idp,
 		str *attrs)
 {
 	dpl_node_p rulep;
 	dpl_index_p indexp;
 	int user_len, rez;
 	char b;
+	pcre *match_re;
 
 	if(!input.s || !input.len) {
 		LM_ERR("invalid input string\n");
@@ -338,9 +387,22 @@ search_rule:
 		switch(rulep->matchop) {
 
 			case DP_REGEX_OP:
-				LM_DBG("regex operator testing\n");
-				rez = pcre_exec(rulep->match_comp, NULL, input.s, input.len,
+				LM_DBG("regex operator testing over [%.*s]\n",
+						input.len, input.s);
+				if(rulep->tflags&DP_TFLAGS_PV_MATCH) {
+					match_re = dpl_dynamic_pcre(msg, &rulep->match_exp, NULL);
+					if(match_re==NULL) {
+						/* failed to compile dynamic pcre -- ignore */
+						continue;
+					}
+				} else {
+					match_re = rulep->match_comp;
+				}
+				rez = pcre_exec(match_re, NULL, input.s, input.len,
 						0, 0, NULL, 0);
+				if(rulep->tflags&DP_TFLAGS_PV_MATCH) {
+					pcre_free(match_re);
+				}
 				break;
 
 			case DP_EQUAL_OP:
-- 
2.1.3

